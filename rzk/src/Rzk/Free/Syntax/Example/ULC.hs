{-# OPTIONS_GHC -fno-warn-unused-do-bind -fno-warn-orphans #-}
{-# LANGUAGE DeriveFoldable       #-}
{-# LANGUAGE DeriveFunctor        #-}
{-# LANGUAGE DeriveTraversable    #-}
{-# LANGUAGE FlexibleInstances    #-}
{-# LANGUAGE LambdaCase           #-}
{-# LANGUAGE OverloadedStrings    #-}
{-# LANGUAGE PatternSynonyms      #-}
{-# LANGUAGE TemplateHaskell      #-}
{-# LANGUAGE TypeApplications     #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE ViewPatterns         #-}
module Rzk.Free.Syntax.Example.ULC where

import           Bound.Scope
import           Control.Applicative
import           Data.Bifunctor.TH
import           Data.Char                                 (chr, isPrint,
                                                            isSpace, ord)
import           Data.Coerce                               (coerce)
import qualified Data.HashSet                              as HashSet
import           Data.List                                 (foldl')
import           Data.String                               (IsString (..))
import qualified Data.Text                                 as Text
import           Data.Text.Prettyprint.Doc                 as Doc
import           Data.Text.Prettyprint.Doc.Render.Terminal (putDoc)
import           System.IO.Unsafe                          (unsafePerformIO)
import           Text.Parser.Token
import           Text.Parser.Token.Style                   (emptyIdents)
import           Text.Trifecta                             as Trifecta

import           Rzk.Free.Bound.Name
import           Rzk.Free.Syntax.FreeScoped
import           Rzk.Free.Syntax.FreeScoped.Unification    (UFreeScoped,
                                                            toMetaVars)
import           Rzk.Free.Syntax.FreeScoped.Unification2   (HigherOrderUnifiable (..),
                                                            Unifiable (..),
                                                            driver, mkApps)
import qualified Rzk.Syntax.Var                            as Rzk

-- * Definition

-- | Generating functor for terms in untyped \(\lambda\)-calculus.
data TermF scope term
  = LamF scope      -- ^ Abstraction: \(\lambda x. T\)
  | AppF term term  -- ^ Application: \(T_1 T_2\)
  deriving (Show, Functor, Foldable, Traversable)

deriveBifunctor ''TermF
deriveBifoldable ''TermF
deriveBitraversable ''TermF

-- | A term in untyped \(\lambda\)-calculus
-- is freely generated by 'TermF':
--
-- * @'Term' b a@ is a term with free variables in @a@ and bound variables in @b@
-- * @'Name' b ()@ tells us that each \(\lambda\)-abstraction binds exactly one variable
-- (since bound variables are indexed by @()@)
type Term b = FreeScoped (Name b ()) TermF

-- | A helper type synonym for the scoped terms.
-- These can be found, for example, in a body of a \(\lambda\)-abstraction.
type ScopedTerm b a = Scope (Name b ()) (Term b) a

-- | Term with 'String' identitiers for bound and free variables.
type Term' = Term Rzk.Var Rzk.Var

-- ** Simple pattern synonyms

-- | A variable.
pattern Var :: a -> Term b a
pattern Var x = PureScoped x

-- | A \(\lambda\)-abstraction.
pattern Lam :: ScopedTerm b a -> Term b a
pattern Lam body = FreeScoped (LamF body)

-- | An application of one term to another.
pattern App :: Term b a -> Term b a -> Term b a
pattern App t1 t2 = FreeScoped (AppF t1 t2)

{-# COMPLETE Var, Lam, App #-}

-- ** Telescoped applications and abstractions

-- | If a term is a series of applications, split
-- it into its head and a non-empty list of arguments.
--
-- >>> t = App (App (App (Var "f") (Var "x")) (Var "y")) (Var "z") :: Term String String
-- >>> t
-- f x y z
-- >>> appList t
-- Just (f,[x,y,z])
-- >>> appList  (Var "f" :: Term String String)
-- Nothing
appList :: Term b a -> Maybe (Term b a, [Term b a])
appList = \case
  App t1 t2 -> Just (go t1 [t2])
  _ -> Nothing
  where
    go (App t x) xs = go t (x:xs)
    go t xs         = (t, xs)

-- | Split a term into its head and a (possibly empty) list of arguments.
--
-- >>> t = App (App (App (Var "f") (Var "x")) (Var "y")) (Var "z") :: Term String String
-- >>> peelApps  t
-- (f,[x,y,z])
-- >>> peelApps (Var "f" :: Term String String)
-- (f,[])
peelApps :: Term b a -> (Term b a, [Term b a])
peelApps = go []
  where
    go xs (App t x) = go (x:xs) t
    go xs t         = (t, xs)

-- | Abstract over one variable in a term.
--
-- >>> lam "x" (App (Var "f") (Var "x")) :: Term String String
-- λx₁ → f x₁
-- >>> lam "f" (App (Var "f") (Var "x")) :: Term String String
-- λx₁ → x₁ x
lam :: Eq a => a -> Term a a -> Term a a
lam x body = Lam (abstract1Name x body)

-- | Given a scope with bound variables indexed by integer numbers,
-- build a term with as many \(\lambda\)-abstractions as necessary
-- to abstract away the entire scope.
mkLams :: Int -> Scope Int (Term b) a -> Term b a
mkLams n = go n []
  where
    go :: Int -> [a] -> Scope Int (Term b) a -> Term b a
    go 0 xs s = instantiateVars xs s
    go k xs s = Lam (abstract1Unnamed (go (k - 1) (map Just xs <> [Nothing]) (Just <$> s)))

-- | A pattern synonym corresponding to 'appList'.
pattern Apps :: Term b a -> [Term b a] -> Term b a
pattern Apps f xs <- (appList -> Just (f, xs))
  where
    Apps f xs = foldl' App f xs

{-# COMPLETE Var, Lam, Apps #-}

-- * Evaluation

-- | Evaluate a term to its weak head normal form (WHNF).
--
-- >>> t = lam "s" (lam "z" (App (Var "s") (App (Var "s") (Var "z")))) :: Term String String
-- >>> App t t
-- (λx₁ → λx₂ → x₁ (x₁ x₂)) (λx₁ → λx₂ → x₁ (x₁ x₂))
-- >>> whnf (App t t)
-- λx₁ → (λx₂ → λx₃ → x₂ (x₂ x₃)) ((λx₂ → λx₃ → x₂ (x₂ x₃)) x₁)
whnf :: Term b a -> Term b a
whnf = \case
  App fun arg ->
    -- to evaluate application we first evaluate
    -- applied function term to its weak head normal form
    case whnf fun of
      -- if it turns out to be a lambda abstraction
      -- then we perform substitution and recursively compute WHNF of the result
      Lam body -> whnf (instantiate1 arg body)
      -- otherwise we stop evaluation
      fun'     -> App fun' arg
  -- lambda abstractions and variables stay unchanged
  t -> t

-- | Evaluate a term to its normal form (NF).
--
-- >>> t = lam "s" (lam "z" (App (Var "s") (App (Var "s") (Var "z")))) :: Term String String
-- >>> App t t
-- (λx₁ → λx₂ → x₁ (x₁ x₂)) (λx₁ → λx₂ → x₁ (x₁ x₂))
-- >>> nf (App t t)
-- λx₁ → λx₂ → x₁ (x₁ (x₁ (x₁ x₂)))
nf :: Term b a -> Term b a
nf = \case
  App fun arg ->
    -- to evaluate application we first evaluate
    -- applied function term to its weak head normal form
    case whnf fun of
      -- if it turns out to be a lambda abstraction
      -- then we perform substitution and recursively compute NF of the result
      Lam body -> nf (instantiate1 arg body)
      -- otherwise we compute NF of both function and argument terms
      fun'     -> App (nf fun') (nf arg)
  -- when encountering a lambda-abstraction
  -- we evaluate its body to its normal form
  Lam body -> Lam (nfScope body)
  -- variables stay unchanged
  t@Var{} -> t
  where
    nfScope = toScope . nf . fromScope

-- * Unification

instance Unifiable TermF where
  zipMatch (AppF f1 x1) (AppF f2 x2)
    = Just (AppF (Right (f1, f2)) (Right (x1, x2)))
  zipMatch (LamF body1) (LamF body2)
    = Just (LamF (Right (body1, body2)))
  zipMatch _ _ = Nothing

instance HigherOrderUnifiable TermF where
  appSome _ []     = error "cannot apply to zero arguments"
  appSome f (x:xs) = (AppF f x, xs)

  unAppSome (AppF f x) = Just (f, [x])
  unAppSome _          = Nothing

  abstract = LamF

-- | A term with unification metavariables in untyped \(\lambda\)-calculus
-- freely generated by 'TermF'.
--
--
type UTerm b a v = UFreeScoped (Name b ()) TermF a v

type UTerm' = UTerm Rzk.Var Rzk.Var Rzk.Var

unifyTerms
  :: (Eq v, Eq a)
  => [v]
  -> UTerm b a v
  -> UTerm b a v
  -> [([(v, UTerm b a v)], [(UTerm b a v, UTerm b a v)])]
unifyTerms mvars t1 t2 = driver mvars whnf (t1, t2)

unifyTerms_
  :: (Eq v, Eq a)
  => [v]
  -> UTerm b a v
  -> UTerm b a v
  -> [(v, UTerm b a v)]
unifyTerms_ mvars t1 t2 = fst (head (unifyTerms mvars t1 t2))

unifyTerms'
  :: UTerm'
  -> UTerm'
  -> [([(Rzk.Var, UTerm')], [(UTerm', UTerm')])]
unifyTerms' = unifyTerms (iterate succ "?")

-- | Unify two terms with meta-variables.
--
-- >>> t1 = "\\x -> \\y -> ?f x y" :: UTerm'
-- >>> t2 = "\\x -> \\y -> y (x y)" :: UTerm'
-- >>> t1
-- λx₁ → λx₂ → ?f x₁ x₂
-- >>> t2
-- λx₁ → λx₂ → x₂ (x₁ x₂)
-- >>> unifyTerms'_ t1 t2
-- [(f,λx₁ → λx₂ → x₂ ((λx₃ → λx₄ → x₄ ((λx₅ → λx₆ → x₆) x₄ x₃)) x₂ x₁)),(?₂,λx₁ → λx₂ → x₂ ((λx₃ → λx₄ → x₄) x₂ x₁)),(?₃,λx₁ → λx₂ → x₂)]
unifyTerms'_
  :: UTerm'
  -> UTerm'
  -> [(Rzk.Var, UTerm')]
unifyTerms'_ t1 t2 = fst (head (unifyTerms' t1 t2))

-- * Parsing

pTerm :: Parser Term'
pTerm = pApps <|> Trifecta.parens pTerm

pApps :: Parser Term'
pApps = do
  f <- pNotAppTerm
  args <- many pNotAppTerm
  return (mkApps f args)

pNotAppTerm :: Parser Term'
pNotAppTerm = pVar <|> pLam <|> Trifecta.parens pTerm

pVar :: Parser Term'
pVar = Var <$> pIdent

pIdent :: Parser Rzk.Var
pIdent = Rzk.Var . Text.pack <$> ident pIdentStyle

pIdentStyle :: IdentifierStyle Parser
pIdentStyle = (emptyIdents @Parser)
  { _styleStart     = satisfy isIdentChar
  , _styleLetter    = satisfy isIdentChar
  , _styleReserved  = HashSet.fromList [ "λ", "\\", "→", "->" ]
  }

pLam :: Parser Term'
pLam = do
  symbol "λ" <|> symbol "\\"
  x <- pIdent
  symbol "->" <|> symbol "→"
  t <- pTerm
  return (Lam (abstract1Name x t))

-- ** Char predicates

isIdentChar :: Char -> Bool
isIdentChar c = isPrint c && not (isSpace c) && not (isDelim c)

isDelim :: Char -> Bool
isDelim c = c `elem` ("()[]{},\\λ→" :: String)

-- * Orphan 'IsString' instances

instance IsString Term' where
  fromString = unsafeParseTerm

instance IsString UTerm' where
  fromString = toUTerm . fromString
    where
      toUTerm = toMetaVars $ \x ->
        if "?" `Text.isPrefixOf` coerce x
           then Just (coerce (Text.drop 1) x)
           else Nothing

unsafeParseTerm :: String -> Term'
unsafeParseTerm = unsafeParseString pTerm

unsafeParseString :: Parser a -> String -> a
unsafeParseString parser input =
  case parseString parser mempty input of
    Success x       -> x
    Failure errInfo -> unsafePerformIO $ do
      putDoc (_errDoc errInfo <> "\n")
      error "Parser error while attempting unsafeParseString"

-- * Pretty-printing

instance Pretty Rzk.Var where
  pretty (Rzk.Var x) = pretty x

-- | Uses 'Pretty' instance.
instance (Pretty a, Pretty b, IsString a) => Show (Term b a) where
  show = show . pretty

-- | Uses default names (@x@ with a positive integer subscript) for bound variables:
instance (Pretty a, Pretty b, IsString a) => Pretty (Term b a) where
  pretty = ppTerm defaultFreshVars
    where
      defaultFreshVars = [ fromString ("x" <> toIndex i) | i <- [1..] ]

      toIndex n = index
        where
          digitToSub c = chr ((ord c - ord '0') + ord '₀')
          index = map digitToSub (show n)

-- | Pretty-print an untyped term.
ppTerm :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTerm vars = \case
  Var x -> pretty x
  App f x -> ppTermFun vars f <+> ppTermArg vars x
  Lam body -> ppScopedTerm vars body $ \x body' ->
    "λ" <> pretty x <+> "→" <+> body'

-- | Pretty-print an untyped in a head position.
ppTermFun :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTermFun vars = \case
  t@Var{} -> ppTerm vars t
  t@App{} -> ppTerm vars t

  t@Lam{} -> Doc.parens (ppTerm vars t)

-- | Pretty-print an untyped in an argument position.
ppTermArg :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTermArg vars = \case
  t@Var{} -> ppTerm vars t

  t@App{} -> Doc.parens (ppTerm vars t)
  t@Lam{} -> Doc.parens (ppTerm vars t)

ppScopedTerm
  :: (Pretty a, Pretty b)
  => [a] -> ScopedTerm b a -> (a -> Doc ann -> Doc ann) -> Doc ann
ppScopedTerm [] _ _            = error "not enough fresh names"
ppScopedTerm (x:xs) t withScope = withScope x (ppTerm xs (instantiate1 (Var x) t))
