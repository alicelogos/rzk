{-# OPTIONS_GHC -fno-warn-unused-do-bind -fno-warn-orphans #-}
{-# LANGUAGE DeriveFoldable             #-}
{-# LANGUAGE DeriveFunctor              #-}
{-# LANGUAGE DeriveTraversable          #-}
{-# LANGUAGE FlexibleContexts           #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE FunctionalDependencies     #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase                 #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE RankNTypes                 #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE TypeSynonymInstances       #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
-- |
-- Martin-L\"of Type Theory.
module Rzk.Free.Syntax.Example.MLTT where

import           Bound.Scope                               (Scope, fromScope,
                                                            instantiate1,
                                                            instantiateVars,
                                                            toScope)
import qualified Bound.Var                                 as Bound
import           Control.Applicative
import           Control.Monad.State
import           Data.Bifunctor
import           Data.Bifunctor.TH
import           Data.Bitraversable
import           Data.Char                                 (chr, isPrint,
                                                            isSpace, ord)
import           Data.Coerce                               (coerce)
import qualified Data.HashSet                              as HashSet
import           Data.List                                 (foldl')
import           Data.String                               (IsString (..))
import qualified Data.Text                                 as Text
import           Data.Text.Prettyprint.Doc                 as Doc
import           Data.Text.Prettyprint.Doc.Render.Terminal (putDoc)
import           System.IO.Unsafe                          (unsafePerformIO)
import           Text.Parser.Token
import           Text.Parser.Token.Style                   (emptyIdents)
import           Text.Trifecta                             as Trifecta

import           Rzk.Free.Bound.Name
import           Rzk.Free.Syntax.FreeScoped
import           Rzk.Free.Syntax.FreeScoped.Unification    (MonadBind,
                                                            UFreeScoped,
                                                            UVar (..),
                                                            freshMeta,
                                                            toMetaVars)
import qualified Rzk.Free.Syntax.FreeScoped.Unification    as U
import           Rzk.Free.Syntax.FreeScoped.Unification2   (Unifiable (..),
                                                            driver, manySubst,
                                                            mkApps, unify)
import qualified Rzk.Syntax.Var                            as Rzk

-- * Definition

-- | Generating functor for terms in Martin-Loef Type Theory.
data TermF scope term
  = UniverseF !Int   -- ^ Universe type \(\mathcal{U}_i\)

  | SigmaF term scope -- ^ A dependent sum type (\(\Sigma\)-type): \(\sum_{x : A} B(x)\)
  | PairF term term   -- ^ A dependent pair \((T_1, T_2)\).
  | FirstF term        -- ^ Project first component of a (dependent) pair: \(\pi_{1} T\).
  | SecondF term       -- ^ Project second component of a (dependent) pair: \(\pi_{2} T\).

  | PiF term scope  -- ^ A dependent product type (\(\Pi\)-type): \(\prod_{x : A} B(x)).
  | LamF scope      -- ^ Abstraction: \(\lambda x. T\)
  | AppF term term  -- ^ Application: \(T_1 T_2\)

  | IdF term term term
  -- ^ Identity type former \(x =_A y\) (corresponding to term @IdType a x y@).
  | ReflF term term
  -- ^ Trivial inhabitant of \(x =_A x\) for any type \(A\) and \(x : A\).
  -- @Refl a x@ corresponds to \(\mathsf{refl}_{A} x\).
  | JF term term term term term term
  -- ^ Path induction (for identity types).
  -- For any type \(A\) and \(a : A\), type family
  -- \(C : \prod_{x : A} ((a =_A x) \to \mathcal{U})\)
  -- and \(d : C(a,\mathsf{refl}_a)\)
  -- and \(x : A\)
  -- and \(p : a =_A x\)
  -- we have \(\mathcal{J}(A, a, C, d, x, p) : C(x, p)\).
  deriving (Show, Functor, Foldable, Traversable)

-- | An (untyped) term in Martin-Lof Type Theory
-- is freely generated by 'TermF':
--
-- * @'Term' b a@ is a term with free variables in @a@ and bound variables in @b@
-- * @'Name' b ()@ tells us that each \(\lambda\)-abstraction binds exactly one variable
-- (since bound variables are indexed by @()@)
type Term b = FreeScoped (Name b ()) TermF

-- | A helper type synonym for the scoped terms.
-- These can be found, for example, in a body of a \(\lambda\)-abstraction.
type ScopedTerm b a = Scope (Name b ()) (Term b) a

-- | Term with 'String' identitiers for bound and free variables.
type Term' = Term Rzk.Var Rzk.Var

-- ** Untyped pattern synonyms

-- | A variable.
pattern Var :: a -> Term b a
pattern Var x = PureScoped x

-- | Universe type \(\mathcal{U}_i\)
pattern Universe :: Int -> Term b a
pattern Universe i = FreeScoped (UniverseF i)

-- | Identity type former \(x =_A y\) (corresponding to term @IdType a x y@).
pattern Id :: Term b a -> Term b a -> Term b a -> Term b a
pattern Id a x y = FreeScoped (IdF a x y)

-- | Trivial inhabitant of \(x =_A x\) for any type \(A\) and \(x : A\).
-- @Refl a x@ corresponds to \(\mathsf{refl}_{A} x\).
pattern Refl :: Term b a -> Term b a -> Term b a
pattern Refl a x = FreeScoped (ReflF a x)

-- | Path induction (for identity types).
-- For any type \(A\) and \(a : A\), type family
-- \(C : \prod_{x : A} ((a =_A x) \to \mathcal{U})\)
-- and \(d : C(a,\mathsf{refl}_a)\)
-- and \(x : A\)
-- and \(p : a =_A x\)
-- we have \(\mathcal{J}(A, a, C, d, x, p) : C(x, p)\).
pattern J
  :: Term b a -> Term b a -> Term b a -> Term b a -> Term b a -> Term b a -> Term b a
pattern J tA a tC d x p = FreeScoped (JF tA a tC d x p)

-- | A dependent sum type (\(\Sigma\)-type): \(\sum_{x : A} B(x)\)
pattern Sigma :: Term b a -> ScopedTerm b a -> Term b a
pattern Sigma a b = FreeScoped (SigmaF a b)

-- | A dependent pair \((T_1, T_2)\).
pattern Pair :: Term b a -> Term b a -> Term b a
pattern Pair t1 t2 = FreeScoped (PairF t1 t2)

-- | Project first component of a (dependent) pair: \(\pi_{1} T\).
pattern First :: Term b a -> Term b a
pattern First t = FreeScoped (FirstF t)

-- | Project second component of a (dependent) pair: \(\pi_{2} T\).
pattern Second :: Term b a -> Term b a
pattern Second t = FreeScoped (SecondF t)

-- | A dependent product type (\(\Pi\)-type): \(\prod_{x : A} B(x)).
pattern Pi :: Term b a -> ScopedTerm b a -> Term b a
pattern Pi a b = FreeScoped (PiF a b)

-- | A \(\lambda\)-abstraction.
pattern Lam :: ScopedTerm b a -> Term b a
pattern Lam body = FreeScoped (LamF body)

-- | An application of one term to another.
pattern App :: Term b a -> Term b a -> Term b a
pattern App t1 t2 = FreeScoped (AppF t1 t2)

{-# COMPLETE Var, Universe, Sigma, Pair, First, Second, Pi, Lam, App, Id, Refl, J #-}

-- ** Telescoped applications and abstractions

-- | If a term is a series of applications, split
-- it into its head and a non-empty list of arguments.
--
-- >>> t = App (App (App (Var "f") (Var "x")) (Var "y")) (Var "z") :: Term String String
-- >>> t
-- f x y z
-- >>> appList t
-- Just (f,[x,y,z])
-- >>> appList  (Var "f" :: Term String String)
-- Nothing
appList :: Term b a -> Maybe (Term b a, [Term b a])
appList = \case
  App t1 t2 -> Just (go t1 [t2])
  _ -> Nothing
  where
    go (App t x) xs = go t (x:xs)
    go t xs         = (t, xs)

-- | Split a term into its head and a (possibly empty) list of arguments.
--
-- >>> t = App (App (App (Var "f") (Var "x")) (Var "y")) (Var "z") :: Term String String
-- >>> peelApps  t
-- (f,[x,y,z])
-- >>> peelApps (Var "f" :: Term String String)
-- (f,[])
peelApps :: Term b a -> (Term b a, [Term b a])
peelApps = go []
  where
    go xs (App t x) = go (x:xs) t
    go xs t         = (t, xs)

-- | Abstract over one variable in a term.
--
-- >>> lam "x" (App (Var "f") (Var "x")) :: Term String String
-- λx₁ → f x₁
-- >>> lam "f" (App (Var "f") (Var "x")) :: Term String String
-- λx₁ → x₁ x
lam :: Eq a => a -> Term a a -> Term a a
lam x body = Lam (abstract1Name x body)

-- | Given a scope with bound variables indexed by integer numbers,
-- build a term with as many \(\lambda\)-abstractions as necessary
-- to abstract away the entire scope.
--
-- >>> t1 = App (Var "x") (Var "y") :: Term String String
-- >>> t2 = abstract (`elemIndex` ["x","y"]) t1 :: Scope Int (Term String) String
-- >>> mkLams 2 t2
-- λx₁ → λx₂ → x₁ x₂
--
-- It is possible to abstract over more variables that there are bound variables:
--
-- >>> t1 = App (Var "x") (Var "y") :: Term String String
-- >>> t2 = abstract (`elemIndex` ["x","y"]) t1 :: Scope Int (Term String) String
-- >>> mkLams 3 t2
-- λx₁ → λx₂ → λx₃ → x₁ x₂
--
-- However, using less variables will lead to an exception.
mkLams :: Int -> Scope Int (Term b) a -> Term b a
mkLams n = go n []
  where
    go :: Int -> [a] -> Scope Int (Term b) a -> Term b a
    go 0 xs s = instantiateVars xs s
    go k xs s = Lam (abstract1Unnamed (go (k - 1) (map Just xs <> [Nothing]) (Just <$> s)))

-- | A pattern synonym corresponding to 'appList'.
pattern Apps :: Term b a -> [Term b a] -> Term b a
pattern Apps f xs <- (appList -> Just (f, xs))
  where
    Apps f xs = foldl' App f xs

-- * Evaluation

-- | Evaluate a term to its weak head normal form (WHNF).
--
-- >>> t = lam "s" (lam "z" (App (Var "s") (App (Var "s") (Var "z")))) :: Term String String
-- >>> App t t
-- (λx₁ → λx₂ → x₁ (x₁ x₂)) (λx₁ → λx₂ → x₁ (x₁ x₂))
-- >>> whnf (App t t)
-- λx₁ → (λx₂ → λx₃ → x₂ (x₂ x₃)) ((λx₂ → λx₃ → x₂ (x₂ x₃)) x₁)
whnf :: Term b a -> Term b a
whnf = untyped . whnfT . transFreeScopedT (`TypedF` error "undefined type")

-- | Evaluate a term to its normal form (NF).
--
-- >>> t = lam "s" (lam "z" (App (Var "s") (App (Var "s") (Var "z")))) :: Term String String
-- >>> App t t
-- (λx₁ → λx₂ → x₁ (x₁ x₂)) (λx₁ → λx₂ → x₁ (x₁ x₂))
-- >>> nf (App t t)
-- λx₁ → λx₂ → x₁ (x₁ (x₁ (x₁ x₂)))
nf :: Term b a -> Term b a
nf = untyped . nfT . transFreeScopedT (`TypedF` error "undefined type")

-- * Unification

instance Unifiable TermF where
  zipMatch (AppF f1 x1) (AppF f2 x2)
    = Just (AppF (Right (f1, f2)) (Right (x1, x2)))
  zipMatch (LamF body1) (LamF body2)
    = Just (LamF (Right (body1, body2)))
  zipMatch _ _ = Nothing

  appSome _ []     = error "cannot apply to zero arguments"
  appSome f (x:xs) = (AppF f x, xs)

  unAppSome (AppF f x) = Just (f, [x])
  unAppSome _          = Nothing

  abstract = LamF

-- | A term with unification metavariables in untyped \(\lambda\)-calculus
-- freely generated by 'TermF'.
--
--
type UTerm b a v = UFreeScoped (Name b ()) TermF a v

type UTerm' = UTerm Rzk.Var Rzk.Var Rzk.Var

unifyTerms
  :: (Eq v, Eq a)
  => [v]
  -> UTerm b a v
  -> UTerm b a v
  -> [([(v, UTerm b a v)], [(UTerm b a v, UTerm b a v)])]
unifyTerms mvars t1 t2 = driver mvars whnf (t1, t2)

unifyTerms_
  :: (Eq v, Eq a)
  => [v]
  -> UTerm b a v
  -> UTerm b a v
  -> [(v, UTerm b a v)]
unifyTerms_ mvars t1 t2 = fst (head (unifyTerms mvars t1 t2))

unifyTerms'
  :: UTerm'
  -> UTerm'
  -> [([(Rzk.Var, UTerm')], [(UTerm', UTerm')])]
unifyTerms' = unifyTerms (iterate succ "?")

-- | Unify two terms with meta-variables.
--
-- >>> t1 = "\\x -> \\y -> ?f x y" :: UTerm'
-- >>> t2 = "\\x -> \\y -> y (x y)" :: UTerm'
-- >>> t1
-- λx₁ → λx₂ → ?f x₁ x₂
-- >>> t2
-- λx₁ → λx₂ → x₂ (x₁ x₂)
-- >>> unifyTerms'_ t1 t2
-- [(f,λx₁ → λx₂ → x₂ ((λx₃ → λx₄ → x₄ ((λx₅ → λx₆ → x₆) x₄ x₃)) x₂ x₁)),(?₂,λx₁ → λx₂ → x₂ ((λx₃ → λx₄ → x₄) x₂ x₁)),(?₃,λx₁ → λx₂ → x₂)]
unifyTerms'_
  :: UTerm'
  -> UTerm'
  -> [(Rzk.Var, UTerm')]
unifyTerms'_ t1 t2 = fst (head (unifyTerms' t1 t2))

-- * Parsing

pTerm :: Parser Term'
pTerm = pApps <|> Trifecta.parens pTerm

pApps :: Parser Term'
pApps = do
  f <- pNotAppTerm
  args <- many pNotAppTerm
  return (mkApps f args)

pNotAppTerm :: Parser Term'
pNotAppTerm = pVar <|> pLam <|> Trifecta.parens pTerm

pVar :: Parser Term'
pVar = Var <$> pIdent

pIdent :: Parser Rzk.Var
pIdent = Rzk.Var . Text.pack <$> ident pIdentStyle

pIdentStyle :: IdentifierStyle Parser
pIdentStyle = (emptyIdents @Parser)
  { _styleStart     = satisfy isIdentChar
  , _styleLetter    = satisfy isIdentChar
  , _styleReserved  = HashSet.fromList [ "λ", "\\", "→", "->" ]
  }

pLam :: Parser Term'
pLam = do
  symbol "λ" <|> symbol "\\"
  x <- pIdent
  symbol "->" <|> symbol "→"
  t <- pTerm
  return (Lam (abstract1Name x t))

-- ** Char predicates

isIdentChar :: Char -> Bool
isIdentChar c = isPrint c && not (isSpace c) && not (isDelim c)

isDelim :: Char -> Bool
isDelim c = c `elem` ("()[]{},\\λ→" :: String)

-- * Orphan 'IsString' instances

instance IsString Term' where
  fromString = unsafeParseTerm

instance IsString UTerm' where
  fromString = toUTerm . fromString
    where
      toUTerm = toMetaVars $ \x ->
        if "?" `Text.isPrefixOf` coerce x
           then Just (coerce (Text.drop 1) x)
           else Nothing

unsafeParseTerm :: String -> Term'
unsafeParseTerm = unsafeParseString pTerm

unsafeParseString :: Parser a -> String -> a
unsafeParseString parser input =
  case parseString parser mempty input of
    Success x       -> x
    Failure errInfo -> unsafePerformIO $ do
      putDoc (_errDoc errInfo <> "\n")
      error "Parser error while attempting unsafeParseString"

-- * Pretty-printing

instance Pretty Rzk.Var where
  pretty (Rzk.Var x) = pretty x

-- | Uses 'Pretty' instance.
--
-- >>> mkLams 5 (abstract (const Nothing) (Var "y")) :: Term String String
-- λx₁ → λx₂ → λx₃ → λx₄ → λx₅ → y
instance (Pretty a, Pretty b, IsString a) => Show (Term b a) where
  show = show . pretty

-- | Uses default names (@x@ with a positive integer subscript) for bound variables:
--
-- >>> pretty (mkLams 5 (abstract (const Nothing) (Var "y")) :: Term String String)
-- λx₁ → λx₂ → λx₃ → λx₄ → λx₅ → y
instance (Pretty a, Pretty b, IsString a) => Pretty (Term b a) where
  pretty = ppTerm defaultFreshVars
    where
      defaultFreshVars = [ fromString ("x" <> toIndex i) | i <- [1..] ]

      toIndex n = index
        where
          digitToSub c = chr ((ord c - ord '0') + ord '₀')
          index = map digitToSub (show n)

-- | Pretty-print an untyped term.
ppTerm :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTerm vars = \case
  Var x -> pretty x

  Universe i -> "U" <> pretty i

  Pi a b -> ppScopedTerm vars b $ \x b' ->
    "(" <> pretty x <+> " : " <+> ppTerm vars a <> ") → " <> b'
  Lam body -> ppScopedTerm vars body $ \x body' ->
    "λ" <> pretty x <+> "→" <+> body'
  App f x -> ppTermFun vars f <+> ppTermArg vars x

  Sigma a b -> ppScopedTerm vars b $ \x b' ->
    "∑ (" <> pretty x <+> " : " <+> ppTerm vars a <> "), " <> b'
  Pair t1 t2 -> "(" <> ppTerm vars t1 <> ", " <> ppTerm vars t2 <> ")"
  First t -> "π₁ " <> ppTermArg vars t
  Second t -> "π₂ " <> ppTermArg vars t

  Id a x y -> ppTermArg vars x <+> "=_{" <> ppTerm vars a <> "}" <+> ppTermArg vars y
  Refl a x -> "refl_{" <> ppTerm vars x <> " : " <> ppTerm vars a <> "}"
  J tA a tC d x p -> ppElimWithArgs vars "idJ" [tA, a, tC, d, x, p]

ppElimWithArgs :: (Pretty a, Pretty b) => [a] -> Doc ann -> [Term b a] -> Doc ann
ppElimWithArgs vars name args = name <> tupled (map (ppTermFun vars) args)

-- | Pretty-print an untyped in a head position.
ppTermFun :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTermFun vars = \case
  t@Var{} -> ppTerm vars t
  t@App{} -> ppTerm vars t
  t@First{} -> ppTerm vars t
  t@Second{} -> ppTerm vars t
  t@Pair{} -> ppTerm vars t
  t@Universe{} -> ppTerm vars t
  t@Id{} -> ppTerm vars t
  t@Refl{} -> ppTerm vars t
  t@J{} -> ppTerm vars t

  t@Lam{} -> Doc.parens (ppTerm vars t)
  t@Sigma{} -> Doc.parens (ppTerm vars t)
  t@Pi{} -> Doc.parens (ppTerm vars t)

-- | Pretty-print an untyped in an argument position.
ppTermArg :: (Pretty a, Pretty b) => [a] -> Term b a -> Doc ann
ppTermArg vars = \case
  t@Var{} -> ppTerm vars t
  t@Pair{} -> ppTerm vars t
  t@Universe{} -> ppTerm vars t

  t@App{} -> Doc.parens (ppTerm vars t)
  t@Lam{} -> Doc.parens (ppTerm vars t)
  t@First{} -> Doc.parens (ppTerm vars t)
  t@Second{} -> Doc.parens (ppTerm vars t)
  t@Pi{} -> Doc.parens (ppTerm vars t)
  t@Sigma{} -> Doc.parens (ppTerm vars t)
  t@Id{} -> Doc.parens (ppTerm vars t)
  t@Refl{} -> Doc.parens (ppTerm vars t)
  t@J{} -> Doc.parens (ppTerm vars t)

ppScopedTerm
  :: (Pretty a, Pretty b)
  => [a] -> ScopedTerm b a -> (a -> Doc ann -> Doc ann) -> Doc ann
ppScopedTerm [] _ _            = error "not enough fresh names"
ppScopedTerm (x:xs) t withScope = withScope x (ppTerm xs (instantiate1 (Var x) t))

-- * Typed terms

data TypedF term scope typedTerm = TypedF
  { termF :: term scope typedTerm
  , typeF :: typedTerm
  } deriving (Show, Functor, Foldable, Traversable)

instance Unifiable term => Unifiable (TypedF term) where
  zipMatch (TypedF term1 type1) (TypedF term2 type2) = do
    term <- zipMatch term1 term2
    return (TypedF term (Right (type1, type2)))

  appSome fun args = (TypedF term (error "can't infer type"), args')
    where
      (term, args') = appSome fun args

  unAppSome (TypedF term _type) = do
    (fun, args) <- unAppSome term
    return (fun, args)

  abstract body = TypedF (abstract body) (error "can't infer type")

type TypedTermF = TypedF TermF

-- | An (untyped) term in Martin-Lof Type Theory
-- is freely generated by 'TermF':
--
-- * @'Term' b a@ is a term with free variables in @a@ and bound variables in @b@
-- * @'Name' b ()@ tells us that each \(\lambda\)-abstraction binds exactly one variable
-- (since bound variables are indexed by @()@)
type TypedTerm b = FreeScoped (Name b ()) TypedTermF

-- | A helper type synonym for the scoped terms.
-- These can be found, for example, in a body of a \(\lambda\)-abstraction.
type ScopedTypedTerm b a = Scope (Name b ()) (TypedTerm b) a

-- | Term with 'String' identitiers for bound and free variables.
type TypedTerm' = TypedTerm Rzk.Var Rzk.Var

-- ** Typed pattern synonyms

-- | A variable.
pattern VarT :: a -> TypedTerm b a
pattern VarT x = PureScoped x

-- | Universe type \(\mathcal{U}_i\)
pattern UniverseT :: TypedTerm b a -> Int -> TypedTerm b a
pattern UniverseT ty i = FreeScoped (TypedF (UniverseF i) ty)

-- | Identity type former \(x =_A y\) (corresponding to term @IdType a x y@).
pattern IdT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern IdT ty a x y = FreeScoped (TypedF (IdF a x y) ty)

-- | Trivial inhabitant of \(x =_A x\) for any type \(A\) and \(x : A\).
-- @Refl a x@ corresponds to \(\mathsf{refl}_{A} x\).
pattern ReflT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern ReflT ty a x = FreeScoped (TypedF (ReflF a x) ty)

-- | Path induction (for identity types).
-- For any type \(A\) and \(a : A\), type family
-- \(C : \prod_{x : A} ((a =_A x) \to \mathcal{U})\)
-- and \(d : C(a,\mathsf{refl}_a)\)
-- and \(x : A\)
-- and \(p : a =_A x\)
-- we have \(\mathcal{J}(A, a, C, d, x, p) : C(x, p)\).
pattern JT
  :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern JT ty tA a tC d x p = FreeScoped (TypedF (JF tA a tC d x p) ty)

-- | A dependent sum type (\(\Sigma\)-type): \(\sum_{x : A} B(x)\)
pattern SigmaT :: TypedTerm b a -> TypedTerm b a -> ScopedTypedTerm b a -> TypedTerm b a
pattern SigmaT ty a b = FreeScoped (TypedF (SigmaF a b) ty)

-- | A dependent pair \((T_1, T_2)\).
pattern PairT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern PairT ty t1 t2 = FreeScoped (TypedF (PairF t1 t2) ty)

-- | Project first component of a (dependent) pair: \(\pi_{1} T\).
pattern FirstT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern FirstT ty t = FreeScoped (TypedF (FirstF t) ty)

-- | Project second component of a (dependent) pair: \(\pi_{2} T\).
pattern SecondT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern SecondT ty t = FreeScoped (TypedF (SecondF t) ty)

-- | A dependent product type (\(\Pi\)-type): \(\prod_{x : A} B(x)).
pattern PiT :: TypedTerm b a -> TypedTerm b a -> ScopedTypedTerm b a -> TypedTerm b a
pattern PiT ty a b = FreeScoped (TypedF (PiF a b) ty)

-- | A \(\lambda\)-abstraction.
pattern LamT :: TypedTerm b a -> ScopedTypedTerm b a -> TypedTerm b a
pattern LamT ty body = FreeScoped (TypedF (LamF body) ty)

-- | An application of one term to another.
pattern AppT :: TypedTerm b a -> TypedTerm b a -> TypedTerm b a -> TypedTerm b a
pattern AppT ty t1 t2 = FreeScoped (TypedF (AppF t1 t2) ty)

{-# COMPLETE VarT, UniverseT, SigmaT, PairT, FirstT, SecondT, PiT, LamT, AppT, IdT, ReflT, JT #-}

untyped :: TypedTerm b a -> Term b a
untyped = transFreeScopedT termF

whnfT :: TypedTerm b a -> TypedTerm b a
whnfT = \case
  AppT ty fun arg ->
    -- to evaluate application we first evaluate
    -- applied function term to its weak head normal form
    case whnfT fun of
      -- if it turns out to be a lambda abstraction
      -- then we perform substitution and recursively compute whnfT of the result
      LamT _ty body -> whnfT (instantiate1 arg body)
      -- otherwise we stop evaluation
      fun'          -> AppT ty fun' arg
  FirstT ty arg ->
    case whnfT arg of
      PairT _ty t _ -> whnfT t
      arg'          -> FirstT ty arg'
  SecondT ty arg ->
    case whnfT arg of
      PairT _ty _ t -> whnfT t
      arg'          -> SecondT ty arg'
  JT ty tA a tC d x p ->
    case whnfT p of
      ReflT _ty _ _ -> whnfT d
      p'            -> JT ty tA a tC d x p'
  -- lambda abstractions and variables stay unchanged
  t -> t

nfT :: TypedTerm b a -> TypedTerm b a
nfT = \case
  AppT ty fun arg ->
    -- to evaluate application we first evaluate
    -- applied function term to its weak head normal form
    case whnfT fun of
      -- if it turns out to be a lambda abstraction
      -- then we perform substitution and recursively compute NFT ty of the result
      LamT _ty body -> nfT (instantiate1 arg body)
      -- otherwise we compute NFT ty of both function and argument terms
      fun'          -> AppT ty (nfT fun') (nfT arg)
  -- when encountering a lambda-abstraction
  -- we evaluate its body to its normal form
  LamT ty body -> LamT ty (nfScopeT body)
  PiT ty a b -> PiT ty (nfT a) (nfScopeT b)

  FirstT ty arg ->
    case whnfT arg of
      PairT _ty t _ -> nfT t
      arg'          -> FirstT ty (nfT arg')
  SecondT ty arg ->
    case whnfT arg of
      PairT _ty _ t -> nfT t
      arg'          -> SecondT ty (nfT arg')
  PairT ty t1 t2 -> PairT ty (nfT t1) (nfT t2)
  SigmaT ty a b -> SigmaT ty (nfT a) (nfScopeT b)

  JT ty tA a tC d x p ->
    case whnfT p of
      ReflT _ty _ _ -> nfT d
      p'            -> JT ty (nfT tA) (nfT a) (nfT tC) (nfT d) (nfT x) (nfT p')
  ReflT ty a x -> ReflT ty (nfT a) (nfT x)
  IdT ty a x y -> IdT ty (nfT a) (nfT x) (nfT y)

  t@UniverseT{} -> t

  -- variables stay unchanged
  t@VarT{} -> t
  where
    nfScopeT = toScope . nfT . fromScope

-- | A typed term with unification metavariables in Martin-Lof Type Theory
-- freely generated by 'TypedTermF'.
type UTypedTerm b a v = UFreeScoped (Name b ()) TypedTermF a v

type UScopedTypedTerm b a v = Scope (Name b ()) (TypedTerm b) (UVar (Name b ()) a v)

type UTypedTerm' = UTypedTerm Rzk.Var Rzk.Var Rzk.Var

typeOf :: MonadTypecheck (TypedTerm b a) a m => TypedTerm b a -> m (TypedTerm b a)
typeOf (FreeScoped (TypedF _ ty)) = return ty
typeOf (PureScoped var)           = typeOfFreeVar var

typeOfScoped ::
    ( Eq a, MonadPlus m
    , MonadBind (UTypedTerm b a v) v m
    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m )
  => UScopedTypedTerm b a v -> m (UScopedTypedTerm b a v)
typeOfScoped scope = toScope <$> do
  case fromScope scope of
    FreeScoped (TypedF _ ty) -> return ty
    PureScoped (Bound.F x)   -> fmap Bound.F <$> typeOfFreeVar x
    PureScoped (Bound.B _)   -> VarT . Bound.F . UMetaVar <$> freshMeta

class Monad m => MonadTypecheck term var m | m -> term var, term -> var where
  typeOfFreeVar :: var -> m term
  getConstraints :: m [(term, term)]
  setConstraints :: [(term, term)] -> m ()
  freshFreeVar :: m var

data TypecheckState term var = TypecheckState
  { knownFreeVarTypes :: [(var, term)]
  , constraints       :: [(term, term)]
  , freshFreeVars     :: [var]
  }

initTypecheckState :: TypecheckState term var
initTypecheckState = TypecheckState
  { knownFreeVarTypes = []
  , constraints = []
  , freshFreeVars = [] -- FIXME?
  }

newtype TypecheckT term var m a = TypecheckT
  { runTypecheckT :: StateT (TypecheckState term var) m a }
  deriving (Functor, Applicative, Monad, MonadState (TypecheckState term var), MonadTrans, MonadPlus, Alternative)

instance MonadBind term' var' m => MonadBind term' var' (TypecheckT term var m) where
  freshMeta = TypecheckT (lift U.freshMeta)

evalTypecheckT :: Monad m => TypecheckT term var m a -> TypecheckState term var -> m a
evalTypecheckT = evalStateT . runTypecheckT

evalTypecheckT'
  :: Monad m
  => [v]
  -> TypecheckT term (UVar b a v) (U.AssocBindT term v m) r
  -> m r
evalTypecheckT' mvars m = evalStateT
  (U.runAssocBindT (evalTypecheckT m initTypecheckState))
  U.initBindState { U.freshMetas = mvars }

instance (Eq b, Eq a, Monad m, MonadBind (FreeScoped b' termf (UVar b a v)) v m)
  => MonadTypecheck (FreeScoped b' termf (UVar b a v)) (UVar b a v) (TypecheckT (FreeScoped b' termf (UVar b a v)) (UVar b a v) m) where
  typeOfFreeVar x = do
    mtype <- gets (lookup x . knownFreeVarTypes)
    case mtype of
      Just ty -> return ty
      Nothing -> TypecheckT (PureScoped . UMetaVar <$> lift freshMeta)

  getConstraints = gets constraints
  setConstraints new = modify (\s -> s { constraints = new })

  freshFreeVar = do
    s <- get
    case s of
      TypecheckState{freshFreeVars = x:xs} -> do
        put s { freshFreeVars = xs }
        return x
      _ -> error "not enough fresh free variables"

unifyWithExpected
  :: (Eq a, MonadPlus m, MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m, MonadBind (UTypedTerm b a v) v m)
  => UTypedTerm b a v
  -> UTypedTerm b a v
  -> m (UTypedTerm b a v)
unifyWithExpected t1 t2 = do
  cs <- getConstraints
  (substs, flexflex) <- unify whnfT [] ((t1, t2) : cs)
  setConstraints flexflex
  return (manySubst substs t1)

localTypedVar :: ( Eq a, MonadTypecheck (TypedTerm b a) a m )
  => TypedTerm b a -> (a -> m r) -> m r
localTypedVar = undefined

shouldHaveType ::
    ( Eq a, MonadPlus m
    , MonadBind (UTypedTerm b a v) v m
    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m )
  => UTypedTerm b a v -> UTypedTerm b a v -> m (UTypedTerm b a v)
shouldHaveType term expectedType = do
  actualType <- typeOf term
  actualType `unifyWithExpected` expectedType

inferF ::
    ( Eq a, MonadPlus m
    , MonadBind (UTypedTerm b a v) v m
    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m )
  => TermF (UScopedTypedTerm b a v) (UTypedTerm b a v) -> m (UTypedTerm b a v)
inferF = \case

  AppF fun arg -> do
    typeOf fun >>= \case
      PiT _ a b -> do
        typeOfArg <- typeOf arg
        _ <- typeOfArg `unifyWithExpected` a
        return (instantiate1 arg b)
      _ -> error "type error"

  LamF body -> do
    typeOfBody <- typeOfScoped body
    typeOfArg <- VarT . UMetaVar <$> freshMeta  -- FIXME: can we attach this information to the scope?
    return (PiT universeT typeOfArg typeOfBody)

  PiF typeOfArg typeOfBody -> do
    typeOfArg `shouldHaveType` universeT
    localTypedVar typeOfArg $ \x ->
      instantiate1 (VarT x) typeOfBody `shouldHaveType` universeT
    return universeT

foldFreeScoped
  :: (Bitraversable term, Monad g, Monad m)
  => (forall x. term (Scope b g x) (g x) -> m (g x))
  -> (forall x. x -> m (g x))
  -> FreeScoped b term a
  -> m (g a)
foldFreeScoped phi single = \case
  PureScoped x -> single x
  FreeScoped t -> do
    t' <- bitraverse
            (fmap toScope . foldFreeScoped phi single . fromScope)
            (foldFreeScoped phi single)
            t
    phi t'

dist :: Bound.Var b (UVar b' a v) -> UVar b' (Bound.Var b a) v
dist (Bound.B b)               = UFreeVar (Bound.B b)
dist (Bound.F (UFreeVar x))    = UFreeVar (Bound.F x)
dist (Bound.F (UBoundVar v b)) = UBoundVar v b
dist (Bound.F (UMetaVar m))    = UMetaVar m

dist' :: UVar b' (Bound.Var b a) v -> Bound.Var b (UVar b' a v)
dist' (UFreeVar (Bound.B b)) = (Bound.B b)
dist' (UFreeVar (Bound.F x)) = (Bound.F (UFreeVar x))
dist' (UBoundVar v b)        = (Bound.F (UBoundVar v b))
dist' (UMetaVar m)           = (Bound.F (UMetaVar m))

newtype Typings term a = Typings { getTypings :: [(a, term)] }

-- newtype Typecheck term x m a = Typecheck
--   { runTypecheck :: StateT (Typings term x) m a }
--   deriving (Functor, Applicative, Monad, MonadPlus, Alternative)
--
-- instance (Eq (UVar b' a v), Monad m, MonadBind (FreeScoped b term (UVar b' a v)) v m) =>
--   MonadTypecheck
--     (FreeScoped b term (UVar b' a v))
--     (UVar b' a v)
--     (Typecheck (FreeScoped b term (UVar b' a v)) (UVar b' a v) m) where
--   typeOfFreeVar x = Typecheck $ do
--     mtype <- gets (lookup x . getTypings)
--     case mtype of
--       Nothing -> PureScoped . UMetaVar <$> lift freshMeta
--       Just ty -> return ty
--
-- evalTypecheck :: Monad m => Typecheck term x m a -> m a
-- evalTypecheck = flip evalStateT (Typings []) . runTypecheck

newtype UScopedTypecheck term b m a = UScopedTypecheck
  { runUScopedTypecheck :: StateT (Typings term b) m a }
  deriving (Functor, Applicative, Monad, MonadPlus, Alternative)

evalUScopedTypecheck :: Monad m => UScopedTypecheck term b m a -> m a
evalUScopedTypecheck = flip evalStateT (Typings []) . runUScopedTypecheck

instance (Eq b, Bifunctor term, MonadTypecheck (FreeScoped b term (UVar b' a v)) (UVar b' a v) m, MonadBind (FreeScoped b term (UVar b' a v)) v m) =>
  MonadTypecheck (FreeScoped b term (UVar b' (Bound.Var b a) v)) (UVar b' (Bound.Var b a) v) (UScopedTypecheck (FreeScoped b term (UVar b' (Bound.Var b a) v)) b m) where
    typeOfFreeVar x = UScopedTypecheck $ do
      case x of
        UFreeVar (Bound.B x') -> do
          mtype <- gets (lookup x' . getTypings)
          case mtype of
            Nothing -> PureScoped . UMetaVar <$> lift freshMeta
            Just ty -> return ty
        UFreeVar (Bound.F x') -> fmap from <$> lift (typeOfFreeVar (UFreeVar x'))
        UBoundVar v b         -> fmap from <$> lift (typeOfFreeVar (UBoundVar v b))
        UMetaVar m            -> fmap from <$> lift (typeOfFreeVar (UMetaVar m))
      where
        from (UBoundVar v b) = UBoundVar v b
        from (UFreeVar x)    = UFreeVar (Bound.F x)
        from (UMetaVar m)    = UMetaVar m

    getConstraints = UScopedTypecheck $ fmap (both (fmap from)) <$> lift getConstraints
      where
        both f (x, y) = (f x, f y)

        from (UBoundVar v b) = UBoundVar v b
        from (UFreeVar x)    = UFreeVar (Bound.F x)
        from (UMetaVar m)    = UMetaVar m

    setConstraints cs = UScopedTypecheck $ lift (setConstraints (map (both (fmap to)) cs))
      where
        both f (x, y) = (f x, f y)

        to (UBoundVar v b)        = UBoundVar v b
        to (UFreeVar (Bound.F x)) = UFreeVar x
        to (UFreeVar (Bound.B _)) = error "can't leak constraints with bound variables"
        to (UMetaVar m)           = UMetaVar m

    freshFreeVar = UScopedTypecheck $ from <$> lift freshFreeVar
      where
        from (UBoundVar v b) = UBoundVar v b
        from (UFreeVar x)    = UFreeVar (Bound.F x)
        from (UMetaVar m)    = UMetaVar m

instance (Bifunctor term, MonadBind (FreeScoped b term (UVar b' a v)) v m)
  => MonadBind
        (FreeScoped b term (UVar b' (Bound.Var b a) v))
        v
        (UScopedTypecheck
            (FreeScoped b term (UVar b' (Bound.Var b a) v))
            b m) where
  freshMeta = UScopedTypecheck $ lift U.freshMeta

infer ::
    ( Eq a, MonadPlus m
    , MonadBind (UTypedTerm b a v) v m
    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m )
  => UTerm b a v -> m (UTypedTerm b a v)
infer (PureScoped var) = typeOfFreeVar var
infer (FreeScoped t)   = bitraverse inferScoped infer t >>= inferF

inferScoped :: forall a b v m.
    ( Eq a, MonadPlus m
    , MonadBind (UTypedTerm b a v) v m
    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m )
  => Scope (Name b ()) (FreeScoped (Name b ()) TermF) (UVar (Name b ()) a v)
  -> m (UScopedTypedTerm b a v)
inferScoped
  = fmap (toScope . fmap dist')
  . evalUScopedTypecheck @_ @(UTypedTerm b (Bound.Var (Name b ()) a) v) @(Name b ())
  . infer
  . fmap dist . fromScope

--inferTypeFor ::
--    ( Eq a, MonadPlus m
--    , MonadBind (UTypedTerm b a v) v m
--    , MonadTypecheck (UTypedTerm b a v) (UVar (Name b ()) a v) m)
--  => Term b a -> m (UTypedTerm b a v)
--inferTypeFor = \case
--  Var x -> return (VarT (UFreeVar x))
--  App fun arg -> do
--    fun' <- inferTypeFor fun
--    arg' <- inferTypeFor arg
--    typeOf fun' >>= \case
--      PiT _ a b -> do
--        typeOfArg <- typeOf arg'
--        _ <- typeOfArg `unifyWithExpected` a
--        let typeOfResult = instantiate1 arg' b
--        return (AppT typeOfResult fun' arg')
--      _ -> error "type error"
--  Lam body -> do
--    body' <- inferTypeForScoped body
--    typeOfScoped body' >>= \(typeOfArg, typeOfBody) ->
--      return (PiT universeT typeOfArg typeOfBody)

universeT :: TypedTerm b a
universeT = UniverseT universeT 0

deriveBifunctor ''TermF
deriveBifoldable ''TermF
deriveBitraversable ''TermF

deriveBifunctor ''TypedF
deriveBifoldable ''TypedF
deriveBitraversable ''TypedF

