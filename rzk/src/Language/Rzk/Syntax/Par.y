-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Language.Rzk.Syntax.Par
  ( happyError
  , myLexer
  , pModule
  , pLanguageDecl
  , pLanguage
  , pCommand
  , pListCommand
  , pPattern
  , pParam
  , pListParam
  , pParamDecl
  , pRestriction
  , pListRestriction
  , pTerm7
  , pTerm5
  , pTerm4
  , pTerm3
  , pTerm2
  , pTerm1
  , pTerm
  , pTerm6
  , pListTerm
  ) where

import Prelude

import qualified Language.Rzk.Syntax.Abs
import Language.Rzk.Syntax.Lex

}

%name pModule Module
%name pLanguageDecl LanguageDecl
%name pLanguage Language
%name pCommand Command
%name pListCommand ListCommand
%name pPattern Pattern
%name pParam Param
%name pListParam ListParam
%name pParamDecl ParamDecl
%name pRestriction Restriction
%name pListRestriction ListRestriction
%name pTerm7 Term7
%name pTerm5 Term5
%name pTerm4 Term4
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pTerm6 Term6
%name pListTerm ListTerm
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '#def'      { PT _ (TS _ 1)         }
  '#lang'     { PT _ (TS _ 2)         }
  '('         { PT _ (TS _ 3)         }
  ')'         { PT _ (TS _ 4)         }
  '*'         { PT _ (TS _ 5)         }
  '*_1'       { PT _ (TS _ 6)         }
  ','         { PT _ (TS _ 7)         }
  '->'        { PT _ (TS _ 8)         }
  '/\\'       { PT _ (TS _ 9)         }
  '0_2'       { PT _ (TS _ 10)        }
  '1'         { PT _ (TS _ 11)        }
  '1_2'       { PT _ (TS _ 12)        }
  '2'         { PT _ (TS _ 13)        }
  ':'         { PT _ (TS _ 14)        }
  ':='        { PT _ (TS _ 15)        }
  ';'         { PT _ (TS _ 16)        }
  '<'         { PT _ (TS _ 17)        }
  '<='        { PT _ (TS _ 18)        }
  '='         { PT _ (TS _ 19)        }
  '==='       { PT _ (TS _ 20)        }
  '=_{'       { PT _ (TS _ 21)        }
  '>'         { PT _ (TS _ 22)        }
  'BOT'       { PT _ (TS _ 23)        }
  'CUBE'      { PT _ (TS _ 24)        }
  'Sigma'     { PT _ (TS _ 25)        }
  'TOP'       { PT _ (TS _ 26)        }
  'TOPE'      { PT _ (TS _ 27)        }
  'U'         { PT _ (TS _ 28)        }
  '['         { PT _ (TS _ 29)        }
  '\\'        { PT _ (TS _ 30)        }
  '\\/'       { PT _ (TS _ 31)        }
  ']'         { PT _ (TS _ 32)        }
  '_'         { PT _ (TS _ 33)        }
  'as'        { PT _ (TS _ 34)        }
  'first'     { PT _ (TS _ 35)        }
  'idJ'       { PT _ (TS _ 36)        }
  'recBOT'    { PT _ (TS _ 37)        }
  'recOR'     { PT _ (TS _ 38)        }
  'refl'      { PT _ (TS _ 39)        }
  'refl_{'    { PT _ (TS _ 40)        }
  'rzk-1'     { PT _ (TS _ 41)        }
  'rzk-2'     { PT _ (TS _ 42)        }
  'second'    { PT _ (TS _ 43)        }
  '{'         { PT _ (TS _ 44)        }
  '|'         { PT _ (TS _ 45)        }
  '|->'       { PT _ (TS _ 46)        }
  '}'         { PT _ (TS _ 47)        }
  'Σ'         { PT _ (TS _ 48)        }
  '→'         { PT _ (TS _ 49)        }
  '∑'         { PT _ (TS _ 50)        }
  L_VarIdent  { PT _ (T_VarIdent $$)  }
  L_HoleIdent { PT _ (T_HoleIdent $$) }

%%

VarIdent :: { Language.Rzk.Syntax.Abs.VarIdent }
VarIdent  : L_VarIdent { Language.Rzk.Syntax.Abs.VarIdent $1 }

HoleIdent :: { Language.Rzk.Syntax.Abs.HoleIdent }
HoleIdent  : L_HoleIdent { Language.Rzk.Syntax.Abs.HoleIdent $1 }

Module :: { Language.Rzk.Syntax.Abs.Module }
Module
  : LanguageDecl ListCommand { Language.Rzk.Syntax.Abs.Module $1 $2 }

LanguageDecl :: { Language.Rzk.Syntax.Abs.LanguageDecl }
LanguageDecl
  : '#lang' Language ';' { Language.Rzk.Syntax.Abs.LanguageDecl $2 }

Language :: { Language.Rzk.Syntax.Abs.Language }
Language
  : 'rzk-1' { Language.Rzk.Syntax.Abs.Rzk1 }
  | 'rzk-2' { Language.Rzk.Syntax.Abs.Rzk2 }

Command :: { Language.Rzk.Syntax.Abs.Command }
Command
  : '#def' VarIdent ListParam ':' Term ':=' Term ';' { Language.Rzk.Syntax.Abs.CommandDefine $2 $3 $5 $7 }
  | '#def' VarIdent ':' Term ':=' Term ';' { Language.Rzk.Syntax.Abs.commandDefineNoParams $2 $4 $6 }

ListCommand :: { [Language.Rzk.Syntax.Abs.Command] }
ListCommand
  : {- empty -} { [] } | Command ListCommand { (:) $1 $2 }

Pattern :: { Language.Rzk.Syntax.Abs.Pattern }
Pattern
  : '_' { Language.Rzk.Syntax.Abs.PatternWildcard }
  | VarIdent { Language.Rzk.Syntax.Abs.PatternVar $1 }
  | '(' Pattern ',' Pattern ')' { Language.Rzk.Syntax.Abs.PatternPair $2 $4 }

Param :: { Language.Rzk.Syntax.Abs.Param }
Param
  : Pattern { Language.Rzk.Syntax.Abs.ParamPattern $1 }
  | '(' Pattern ':' Term ')' { Language.Rzk.Syntax.Abs.ParamPatternType $2 $4 }
  | '{' Pattern ':' Term '|' Term '}' { Language.Rzk.Syntax.Abs.ParamPatternShape $2 $4 $6 }

ListParam :: { [Language.Rzk.Syntax.Abs.Param] }
ListParam : Param { (:[]) $1 } | Param ListParam { (:) $1 $2 }

ParamDecl :: { Language.Rzk.Syntax.Abs.ParamDecl }
ParamDecl
  : Term6 { Language.Rzk.Syntax.Abs.ParamType $1 }
  | '(' '_' ':' Term ')' { Language.Rzk.Syntax.Abs.ParamWildcardType $4 }
  | '{' Pattern ':' Term '}' { Language.Rzk.Syntax.Abs.ParamVarType $2 $4 }
  | '(' VarIdent ':' Term ')' { Language.Rzk.Syntax.Abs.paramVarType $2 $4 }
  | '{' '(' Pattern ':' Term ')' '|' Term '}' { Language.Rzk.Syntax.Abs.ParamVarShape $3 $5 $8 }
  | '{' Pattern ':' Term '|' Term '}' { Language.Rzk.Syntax.Abs.paramVarShape $2 $4 $6 }

Restriction :: { Language.Rzk.Syntax.Abs.Restriction }
Restriction
  : Term '|->' Term { Language.Rzk.Syntax.Abs.Restriction $1 $3 }

ListRestriction :: { [Language.Rzk.Syntax.Abs.Restriction] }
ListRestriction
  : Restriction { (:[]) $1 }
  | Restriction ',' ListRestriction { (:) $1 $3 }

Term7 :: { Language.Rzk.Syntax.Abs.Term }
Term7
  : 'U' { Language.Rzk.Syntax.Abs.Universe }
  | 'CUBE' { Language.Rzk.Syntax.Abs.UniverseCube }
  | 'TOPE' { Language.Rzk.Syntax.Abs.UniverseTope }
  | '1' { Language.Rzk.Syntax.Abs.CubeUnit }
  | '*_1' { Language.Rzk.Syntax.Abs.CubeUnitStar }
  | '2' { Language.Rzk.Syntax.Abs.Cube2 }
  | '0_2' { Language.Rzk.Syntax.Abs.Cube2_0 }
  | '1_2' { Language.Rzk.Syntax.Abs.Cube2_1 }
  | 'TOP' { Language.Rzk.Syntax.Abs.TopeTop }
  | 'BOT' { Language.Rzk.Syntax.Abs.TopeBottom }
  | 'recBOT' { Language.Rzk.Syntax.Abs.RecBottom }
  | 'recOR' '(' ListRestriction ')' { Language.Rzk.Syntax.Abs.RecOr $3 }
  | 'recOR' '(' Term ',' Term ',' Term ',' Term ')' { Language.Rzk.Syntax.Abs.recOr $3 $5 $7 $9 }
  | '<' ParamDecl '->' Term '>' { Language.Rzk.Syntax.Abs.typeExtension $2 $4 }
  | '(' Term ',' Term ')' { Language.Rzk.Syntax.Abs.Pair $2 $4 }
  | 'refl' { Language.Rzk.Syntax.Abs.Refl }
  | 'refl_{' Term '}' { Language.Rzk.Syntax.Abs.ReflTerm $2 }
  | 'refl_{' Term ':' Term '}' { Language.Rzk.Syntax.Abs.ReflTermType $2 $4 }
  | 'idJ' '(' Term ',' Term ',' Term ',' Term ',' Term ',' Term ')' { Language.Rzk.Syntax.Abs.IdJ $3 $5 $7 $9 $11 $13 }
  | HoleIdent { Language.Rzk.Syntax.Abs.Hole $1 }
  | VarIdent { Language.Rzk.Syntax.Abs.Var $1 }
  | '(' Term ')' { $2 }

Term5 :: { Language.Rzk.Syntax.Abs.Term }
Term5
  : Term5 '*' Term6 { Language.Rzk.Syntax.Abs.CubeProduct $1 $3 }
  | Term6 { $1 }

Term4 :: { Language.Rzk.Syntax.Abs.Term }
Term4
  : Term5 '===' Term5 { Language.Rzk.Syntax.Abs.TopeEQ $1 $3 }
  | Term5 '<=' Term5 { Language.Rzk.Syntax.Abs.TopeLEQ $1 $3 }
  | Term5 { $1 }

Term3 :: { Language.Rzk.Syntax.Abs.Term }
Term3
  : Term4 '/\\' Term3 { Language.Rzk.Syntax.Abs.TopeAnd $1 $3 }
  | Term4 { $1 }

Term2 :: { Language.Rzk.Syntax.Abs.Term }
Term2
  : Term3 '\\/' Term2 { Language.Rzk.Syntax.Abs.TopeOr $1 $3 }
  | Term3 { $1 }

Term1 :: { Language.Rzk.Syntax.Abs.Term }
Term1
  : ParamDecl '->' Term1 { Language.Rzk.Syntax.Abs.TypeFun $1 $3 }
  | 'Sigma' '(' Pattern ':' Term ')' ',' Term1 { Language.Rzk.Syntax.Abs.TypeSigma $3 $5 $8 }
  | Term2 '=_{' Term '}' Term2 { Language.Rzk.Syntax.Abs.TypeId $1 $3 $5 }
  | Term2 '=' Term2 { Language.Rzk.Syntax.Abs.TypeIdSimple $1 $3 }
  | '\\' ListParam '->' Term1 { Language.Rzk.Syntax.Abs.Lambda $2 $4 }
  | Term2 { $1 }
  | ParamDecl '→' Term1 { Language.Rzk.Syntax.Abs.unicode_TypeFun $1 $3 }
  | 'Σ' '(' Pattern ':' Term ')' ',' Term1 { Language.Rzk.Syntax.Abs.unicode_TypeSigma $3 $5 $8 }
  | '∑' '(' Pattern ':' Term ')' ',' Term1 { Language.Rzk.Syntax.Abs.unicode_TypeSigmaAlt $3 $5 $8 }

Term :: { Language.Rzk.Syntax.Abs.Term }
Term
  : Term1 '[' ListRestriction ']' { Language.Rzk.Syntax.Abs.TypeRestricted $1 $3 }
  | Term2 'as' Term1 { Language.Rzk.Syntax.Abs.TypeAsc $1 $3 }
  | Term1 { $1 }

Term6 :: { Language.Rzk.Syntax.Abs.Term }
Term6
  : Term6 Term7 { Language.Rzk.Syntax.Abs.App $1 $2 }
  | 'first' Term7 { Language.Rzk.Syntax.Abs.First $2 }
  | 'second' Term7 { Language.Rzk.Syntax.Abs.Second $2 }
  | Term7 { $1 }

ListTerm :: { [Language.Rzk.Syntax.Abs.Term] }
ListTerm : Term { (:[]) $1 } | Term ',' ListTerm { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

